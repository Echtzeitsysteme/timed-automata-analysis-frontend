import React from 'react';
import Button from '@mui/material/Button';
import { OpenedSystems, SystemOptionType } from '../viewmodel/OpenedSystems.ts';
import { AnalysisViewModel } from '../viewmodel/AnalysisViewModel.ts';
import { OpenedProcesses } from '../viewmodel/OpenedProcesses.ts';
import { deParseClockComparator } from '../model/ta/clockComparator.ts';
import { useTranslation } from 'react-i18next';

interface ActiveModel {
  viewModel: AnalysisViewModel;
  openedSystems: OpenedSystems;
  openedProcesses: OpenedProcesses;
}

const createFile = async (currentSystem: SystemOptionType) => {
  const prefix =
    '#\n' +
    '# This is a TChecker file\n' +
    '#\n' +
    '# This file has been automatically generated by' +
    '# https://github.com/Echtzeitsysteme/timed-automata-analysis-frontend' +
    '#\n' +
    '# The TChecker file format is described here:\n' +
    '# https://github.com/ticktac-project/tchecker/wiki/TChecker-file-format\n' +
    '#\n\n';
  const systemName = currentSystem.label;
  const systemDef = 'system:' + systemName + '\n' + '\n';
  let taFile = prefix + systemDef;
  let processes = '';
  let events = '';
  let integers = '';
  let synchronizations = '';
  const existingEvents: string[] = [];
  const existingClocks: string[] = [];

  //integers
  currentSystem.integers.forEach((int) => {
    const integer = 'int:' + int.size + ':' + int.min + ':' + int.max + ':' + int.init + ':' + int.name + '\n';
    integers += integer;
  });

  const automatonOptions = currentSystem.processes;
  automatonOptions.forEach((option) => {
    const process = option.label;
    const processDef = 'process:' + process + '\n';

    const ta = option.automaton;

    let clocks = '';
    let locations = '';
    let edges = '';

    //clocks
    ta.clocks.forEach((clock) => {
      //clocks are supposed to be global variables, don't write them multiple times
      const alreadyWritten = existingClocks.some((existingClock) => existingClock == clock.name);
      if (!alreadyWritten) {
        const newClock = 'clock:' + clock.size + ':' + clock.name + '\n';
        clocks += newClock;
        existingClocks.push(clock.name);
      }
    });

    //locations
    ta.locations.forEach((location) => {
      let newLocation = 'location:' + process + ':' + location.name + '{';

      let initial: undefined | string = undefined;
      let invariant: undefined | string = undefined;
      let urgent: undefined | string = undefined;
      let committed: undefined | string = undefined;
      let labels: undefined | string = undefined;
      let layout: undefined | string = undefined;

      if (location.isInitial) {
        initial = 'initial:';
      }
      if (location.invariant != undefined) {
        const invar = 'invariant:';

        const clauses: string[] = [];
        location.invariant.clauses.forEach((clause) => {
          const operator = deParseClockComparator(clause.op);
          const newClause = clause.lhs.name.toString() + operator + clause.rhs.toString();
          clauses.push(newClause);
        });
        const joinedClauses = clauses.join(' && ');

        const freeClauses: string[] = [];
        location.invariant.freeClauses.forEach((clause) => {
          const newClause = clause.term;
          freeClauses.push(newClause);
        });
        const joinedFreeClauses = freeClauses.join(' && ');

        const allClauses = [joinedClauses, joinedFreeClauses].filter((c) => c !== '').join(' && ');
        if (allClauses !== '') {
          invariant = invar + allClauses;
        }
      }
      if (location.urgent) {
        urgent = 'urgent:';
      }
      if (location.committed) {
        committed = 'committed:';
      }
      if (location.labels && location.labels.length > 0) {
        const lbl = 'labels:';
        const allLabels = location.labels.join(', ');
        if (allLabels !== '') {
          labels = lbl + allLabels;
        }
      }
      if (location.setLayout) {
        layout = 'layout:' + location.xCoordinate.toString() + ',' + location.yCoordinate.toString();
      }

      const attributeList = [initial, invariant, urgent, committed, labels, layout]
        .filter((e) => e !== undefined)
        .join(' : ');

      newLocation += attributeList + '}' + '\n';
      locations += newLocation;
    });

    ta.switches.forEach((edge) => {
      //check for events
      if (
        existingEvents.filter((event) => {
          return event === edge.actionLabel;
        }).length == 0
      ) {
        existingEvents.push(edge.actionLabel);
        const newEvent = 'event:' + edge.actionLabel + '\n';
        events += newEvent;
      }
      //actual edge definition
      let newEdge = 'edge:' + process + ':' + edge.source.name + ':' + edge.target.name + ':' + edge.actionLabel + '{';

      let guard: string | undefined = undefined;
      let resetsAndStatements: string | undefined = undefined;

      if (edge.guard != undefined) {
        const prov = 'provided:';

        const clauses: string[] = [];
        edge.guard.clauses.forEach((clause) => {
          const operator = deParseClockComparator(clause.op);
          const newClause = clause.lhs.name.toString() + operator + clause.rhs.toString();
          clauses.push(newClause);
        });
        const joinedClauses = clauses.join(' && ');

        const freeClauses: string[] = [];
        edge.guard.freeClauses.forEach((clause) => {
          const newClause = clause.term;
          freeClauses.push(newClause);
        });
        const joinedFreeClauses = freeClauses.join(' && ');

        const allClauses = [joinedClauses, joinedFreeClauses].filter((c) => c !== '').join(' && ');
        if (allClauses !== '') {
          guard = prov + allClauses;
        }
      }

      const doLbl = 'do:';
      const resetStrings: string[] = [];
      edge.reset.forEach((reset) => {
        resetStrings.push(reset.name + '=0');
      });
      const resetString = resetStrings.join(';');

      const statementsList: string[] = [];
      if (edge.statement != undefined) {
        edge.statement.statements.forEach((stmt) => {
          statementsList.push(stmt.term);
        });
      }
      const statementsString = statementsList.join(';');

      const allDos = [resetString, statementsString].filter((s) => s !== '').join(';');
      if (allDos !== '') {
        resetsAndStatements = doLbl + allDos;
      }

      const attributeList = [guard, resetsAndStatements].filter((e) => e !== undefined).join(' : ');

      newEdge += attributeList + '}' + '\n';
      edges += newEdge;
    });
    const singularProcess = processDef + clocks + locations + edges;
    processes += singularProcess + '\n' + '\n';
  });
  taFile += events + '\n';
  taFile += integers + '\n';
  taFile += processes;

  currentSystem.synchronizations.forEach((syncConstr) => {
    let newSyncConstr = '';

    const syncLbl = 'sync:';
    const syncs: string[] = [];
    syncConstr.syncs.forEach((sync) => {
      let newSync = sync.process + '@' + sync.event;
      if (sync.weakSynchronisation) {
        newSync += '?';
      }
      syncs.push(newSync);
    });
    const syncsStr = syncs.join(':');
    if (syncsStr !== '') {
      newSyncConstr += syncLbl + syncsStr + '\n';
      synchronizations += newSyncConstr;
    }
  });

  taFile += synchronizations;
  //console.log(taFile);

  return taFile;
};

const DownloadButton: React.FC<ActiveModel> = (props) => {
  const { openedSystems, viewModel, openedProcesses } = props;
  const { t } = useTranslation();
  const currentSystem = openedSystems.selectedSystem;
  openedProcesses.selectedOption.automaton = viewModel.ta;
  currentSystem.processes = openedProcesses.automatonOptions;
  //console.log("Current System:", currentSystem);
  const fileName = currentSystem.label + '.tck';

  const downloadModel = async () => {
    try {
      const file = await createFile(currentSystem);

      const blob = new Blob([file]);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fileName;
      a.click();
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <label htmlFor="downloadModel">
      <Button variant="contained" onClick={downloadModel}>
        {t('downloadButton.button')}
      </Button>
    </label>
  );
};

export default DownloadButton;
